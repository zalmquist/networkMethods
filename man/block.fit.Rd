% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/util.R
\name{block.fit}
\alias{block.fit}
\title{Block Fit}
\usage{
block.fit(g, model, measure = c("pearson", "negdist"), diag = FALSE,
  iter = 3000, temp.init = 10, cool = 0.995, hill.climb.refine = TRUE,
  seed = NULL, verbose = TRUE)
}
\arguments{
\item{g}{a network to be analyzed}

\item{model}{a vector or matrix specifying the blockmodel to be fit.  If passed
as a vector, the argument should be given column-wise.  For instance,
two-class blockmodels are fit by passing a vector of the form
c(b11,b21,b12,b22), where bij is the value of the i,j cell in the
blockmodel.  Usually, these values are 1 or 0, although NAs are allowed
(and have the effect of removing the indicated cells from consideration
when evaluating goodness of fit).}

\item{measure}{"pearson" for the standard correlation coefficent (may produce
warnings, which are harmless) or "negdist" for the inverse absolute
distance.}

\item{diag}{should the diagonal be included?}

\item{iter}{number of annealing iterations to employ.}

\item{temp.init}{initial temperature for the annealer.}

\item{cool}{cooling factor for the annealer.}

\item{hill.climb.refine}{should the annealing solution be further refined using}

\item{seed}{an optional vector of initial group memberships.}

\item{verbose}{should the function provide diagnostic output?}

\item{hill-climbing?}{(Can be slow, but guarantees convergence to a local optimum.)
optimum.}
}
\value{
An object of class "blockmodel," with the additional list element block.gof.
  (Note that this object can be printed, etc. using the standard methods
  for this class.)
}
\description{
\code{block.fit} returns an object of class "blockmodel."
}
\examples{
require(sna)
  require(network)
  data(kaptail.ins)
  plot(kaptail.ins)
# Let's try fitting some blockmodels.  Here are several variants on C/P:
kb1<-block.fit(kaptail.ins,c(1,1,1,0))   # Core w/in,out ties
kb2<-block.fit(kaptail.ins,c(1,1,0,0))   # Core w/in ties
kb3<-block.fit(kaptail.ins,c(1,0,1,0))   # Core w/out ties
kb4<-block.fit(kaptail.ins,c(1,0,0,0))   # Isolated core
kb5<-block.fit(kaptail.ins,c(1,NA,NA,0)) # Ignore core/periphery interactions

# Examine the output directly
kb1                                       # These are "blockmodel" objects
summary(kb2)

# Plot each model as a "blocked" data matrix
lab<-kb1$block.membership[kb1$order.vector]
plot.sociomatrix(kb1$blocked.data,labels=list(lab,lab))
lab<-kb2$block.membership[kb2$order.vector]
plot.sociomatrix(kb2$blocked.data,labels=list(lab,lab))
lab<-kb3$block.membership[kb3$order.vector]
plot.sociomatrix(kb3$blocked.data,labels=list(lab,lab))
lab<-kb4$block.membership[kb4$order.vector]
plot.sociomatrix(kb4$blocked.data,labels=list(lab,lab))
lab<-kb5$block.membership[kb5$order.vector]
plot.sociomatrix(kb5$blocked.data,labels=list(lab,lab))

# Plot the original data, with vertices colored by block (black=1, red=2)
plot(kaptail.ins,vertex.col=kb1$block.membership)
plot(kaptail.ins,vertex.col=kb2$block.membership)
plot(kaptail.ins,vertex.col=kb3$block.membership)
plot(kaptail.ins,vertex.col=kb4$block.membership)
plot(kaptail.ins,vertex.col=kb5$block.membership)

# Let's try another example -- this one (from Thuroff) is undirected
data(thuroff.int)
plot(thuroff.int)

# Fit various undirected blockmodels
tb1<-block.fit(thuroff.int,c(1,1,1,0))    # Core w/in,out ties
tb2<-block.fit(thuroff.int,c(1,0,0,0))    # Isolated core
tb3<-block.fit(thuroff.int,c(1,NA,NA,0))  # Ignore core/periphery relations
tb4<-block.fit(thuroff.int,c(1,0,0,1))    # Two cores
tb5<-block.fit(thuroff.int,c(0,1,1,0))    # Bipartite structure - no cores!

# Examine the results via the sociomatrix:
lab<-tb1$block.membership[tb1$order.vector]
plot.sociomatrix(tb1$blocked.data,labels=list(lab,lab))
lab<-tb2$block.membership[tb2$order.vector]
plot.sociomatrix(tb2$blocked.data,labels=list(lab,lab))
lab<-tb3$block.membership[tb3$order.vector]
plot.sociomatrix(tb3$blocked.data,labels=list(lab,lab))
lab<-tb4$block.membership[tb4$order.vector]
plot.sociomatrix(tb4$blocked.data,labels=list(lab,lab))
lab<-tb5$block.membership[tb5$order.vector]
plot.sociomatrix(tb5$blocked.data,labels=list(lab,lab))

# For more information....
#?blockmodel
#?order
#?plot.sociomatrix
#
#-Eigenvector centrality/coreness-----------------------------------------------
#
# Calculate eigenvector centrality for our two sample cases
ev.kt<-evcent(kaptail.ins)
ev.th<-evcent(thuroff.int)

# How does evcent relate to block membership?  Let's compare:
plot(kaptail.ins,vertex.cex=ev.kt*5+0.5,vertex.col=kb5$block.membership)
plot(thuroff.int,vertex.cex=ev.th*5+0.5,vertex.col=tb5$block.membership)

# Can plot the sociomatrices, sorted by evcent (note the sort order)
plot.sociomatrix(kaptail.ins[order(ev.kt),order(ev.kt)])
plot.sociomatrix(thuroff.int[order(ev.th),order(ev.th)])

# For more information....
# ?evcent
}
\author{
Carter T. Butts, University of California, Irvine
}

